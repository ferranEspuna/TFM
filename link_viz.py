import itertools
import os
import colorsys  # Needed for dimming colors

# No matplotlib needed anymore for this version
# No numpy needed if using simple average for roots

# --- Adjustable parameters ---

# Vertex styling
T_DOT_COLOR = "blue"  # Color for vertices in T
V_MINUS_T_DOT_COLOR = "black"  # Color for vertices in V \ T
DOT_THICKNESS = 4.0  # Thickness of vertex dots (pt)
ADD_VERTEX_LABELS = True  # Add labels (A1, B1, etc.) next to vertices

# Link edge styling (Common Link Graph)
LINK_EDGE_COLOR = "red"  # Color of the link graph edges
LINK_EDGE_THICKNESS = "thick"  # TikZ style ("thin", "thick", "very thick") or specify pt (e.g., "1.5pt")

# Original Hyperedge styling (3-uniform edges of G)
DRAW_ORIGINAL_HYPEREDGES = True  # Set to False to hide the original hyperedges
HYPEREDGE_LINE_THICKNESS = 1.5  # Thickness of hyperedge lines (pt)
HYPEREDGE_ROOT_THICKNESS = 2.5  # Thickness of hyperedge root dots (pt)
# Define a BASE color for hyperedges (RGB tuple 0-1)
HYPEREDGE_BASE_COLOR_RGB = (0.4, 0.4, 0.4)  # A neutral gray
HYPEREDGE_BRIGHTNESS = 0.65  # Target brightness for hyperedge colors (0=black, 1=full bright) - Adjust dimming

# Box styling
T_BOX_BG_COLOR = "blue!15"  # Background color for the box around T
V_MINUS_T_BOX_BG_COLOR = "gray!15"  # Background color for the box around V \ T
BOX_MARGIN = 0.7  # Margin around points for boxes
DRAW_BOXES = True  # Whether to draw the background boxes


# --- Utility Functions ---

def dim_rgb(color: tuple[float, float, float], target_brightness: float) -> tuple[float, float, float]:
    """ Dims an RGB color to a specified brightness level. """
    if not (0 <= target_brightness <= 1):
        raise ValueError("Brightness factor must be between 0 and 1.")
    if not color or len(color) != 3:  # Basic check
        return (0, 0, 0)
    try:
        h, l, s = colorsys.rgb_to_hls(*color)
        new_l = min(l, target_brightness)  # Adjust lightness
        new_rgb = colorsys.hls_to_rgb(h, new_l, s)
        return new_rgb
    except Exception as e:
        print(f"Warning: Could not dim color {color}. Error: {e}")
        return color  # Return original color on error


# --- Define the graph G = (V, E) and set T ---

# Vertices V and their coordinates {label: (x, y)}
vertices = {
    'A': (0, 2), 'B': (0, 7),  # Group V1 (Will be T)
    'X': (8, 9), 'Y': (10, 6),
    'Z': (8, 0), 'T': (10, 3)
}

# Define the set T
T = ['A', 'B']  # Let T be the first group V1

# Define the vertices in V \ T
V_minus_T = [v for v in vertices if v not in T]

# Define the hyperedges E of the 3-uniform graph G (K(2,2,2) structure)
hyperedges_G_list = [('A', 'X', 'Y'),  # Hyperedge 1
                     ('A', 'Y', 'T'),  # Hyperedge 2
                     ('B', 'X', 'Y'),  # Hyperedge 3
                     ('B', 'Y', 'T'),  # Hyperedge 4
                     ('A', 'Z', 'T'),  # Hyperedge 5
                     ('B', 'Z', 'T'),  # Hyperedge 6
                     ('A', 'B', 'X'),  # Hyperedge 7
                     ]

hyperedges_G_set = {frozenset(h) for h in hyperedges_G_list}

# Parameters for the link graph definition
k = 3
j = 2

# --- Calculate the common j-link graph edges ---
link_edges = []
required_X_size = k - j
if len(T) >= required_X_size:
    for Y_tuple in itertools.combinations(V_minus_T, j):
        Y = frozenset(Y_tuple)
        is_link_edge = True
        for X_tuple in itertools.combinations(T, required_X_size):
            X = frozenset(X_tuple)
            hyperedge_candidate = X.union(Y)
            if hyperedge_candidate not in hyperedges_G_set:
                is_link_edge = False
                break
        if is_link_edge:
            link_edges.append(Y_tuple)

# --- Prepare TikZ code lines ---
lines = [r"% TikZ code generated by Python script for Common Link Graph visualization",
         r"\begin{tikzpicture}[scale=0.8]"]

# --- Prepare data for drawing original hyperedges (roots mainly) ---
hyperedge_drawing_data = []
if DRAW_ORIGINAL_HYPEREDGES:
    r, g, b = dim_rgb(HYPEREDGE_BASE_COLOR_RGB, HYPEREDGE_BRIGHTNESS)
    lines.append(r"% Define uniform color for original hyperedges")
    lines.append(r"\definecolor{{hyperedgecolor}}{{rgb}}{{{:.3f}, {:.3f}, {:.3f}}}".format(r, g, b))

    for idx, hedge_nodes in enumerate(hyperedges_G_list):
        v1_label, v2_label, v3_label = hedge_nodes
        v1_coords = vertices[v1_label]
        v2_coords = vertices[v2_label]
        v3_coords = vertices[v3_label]
        root_x = (v1_coords[0] + v2_coords[0] + v3_coords[0]) / 3.0
        root_y = (v1_coords[1] + v2_coords[1] + v3_coords[1]) / 3.0

        hyperedge_drawing_data.append({
            "id": idx,
            "nodes": hedge_nodes,
            "root": (root_x, root_y)
            # Color is now the same for all, calculated above
        })

# -- 2. Define Coordinates for Vertices AND Hyperedge Roots --
lines.append(r"% Vertex coordinates")
for label, (x, y) in vertices.items():
    lines.append(r"\coordinate ({}) at ({:.2f}, {:.2f});".format(label, x, y))

if DRAW_ORIGINAL_HYPEREDGES:
    lines.append(r"% Hyperedge root coordinates")
    for data in hyperedge_drawing_data:
        rx, ry = data['root']
        lines.append(r"\coordinate (R{}) at ({:.3f}, {:.3f});".format(data['id'], rx, ry))


# Function to compute bounding box (needed for boxes)
def bounding_box(points_coords, margin=0.5):
    if not points_coords:
        return 0, 0, 0, 0
    x_vals, y_vals = zip(*points_coords)
    return min(x_vals) - margin, max(x_vals) + margin, min(y_vals) - margin, max(y_vals) + margin


# -- 3. Draw Boxes (Optional) -- (DRAWN FIRST in this layer group)
if DRAW_BOXES:
    lines.append(r"% Draw background boxes for T and V \ T")
    # Box for T
    s_points_coords = [vertices[v] for v in T if v in vertices]
    if s_points_coords:
        x_min, x_max, y_min, y_max = bounding_box(s_points_coords, BOX_MARGIN)
        lines.append(
            r"\draw[fill={}, rounded corners, line width=0.5pt, draw=gray] ({:.2f}, {:.2f}) rectangle ({:.2f}, {:.2f});".format(
                T_BOX_BG_COLOR, x_min, y_min, x_max, y_max))
        lines.append(
            r"\node at ({:.2f}, {:.2f}) [anchor=south, align=center] {{$T$}};".format((x_min + x_max) / 2, y_max))
    # Box for V \ T
    v_minus_s_coords = [vertices[v] for v in V_minus_T if v in vertices]
    if v_minus_s_coords:
        x_min, x_max, y_min, y_max = bounding_box(v_minus_s_coords, BOX_MARGIN)
        lines.append(
            r"\draw[fill={}, rounded corners, line width=0.5pt, draw=gray] ({:.2f}, {:.2f}) rectangle ({:.2f}, {:.2f});".format(
                V_MINUS_T_BOX_BG_COLOR, x_min, y_min, x_max, y_max))
        lines.append(r"\node at ({:.2f}, {:.2f}) [anchor=south, align=center] {{$V \setminus T$}};".format(
            (x_min + x_max) / 2, y_max))

# -- 4. Draw Original Hyperedges -- (DRAWN AFTER BOXES)
if DRAW_ORIGINAL_HYPEREDGES:
    lines.append(r"% Draw original hyperedges (using uniform color 'hyperedgecolor')")
    for data in hyperedge_drawing_data:
        edge_id = data['id']
        node1, node2, node3 = data['nodes']
        # Draw the tree edges
        lines.append(
            r"\draw[line width={:.1f}pt, color=hyperedgecolor] (R{}) -- ({});".format(HYPEREDGE_LINE_THICKNESS, edge_id,
                                                                                      node1))
        lines.append(
            r"\draw[line width={:.1f}pt, color=hyperedgecolor] (R{}) -- ({});".format(HYPEREDGE_LINE_THICKNESS, edge_id,
                                                                                      node2))
        lines.append(
            r"\draw[line width={:.1f}pt, color=hyperedgecolor] (R{}) -- ({});".format(HYPEREDGE_LINE_THICKNESS, edge_id,
                                                                                      node3))
        # Draw the hyperedge root dot
        lines.append(r"\fill[color=hyperedgecolor] (R{}) circle ({:.1f}pt);".format(edge_id, HYPEREDGE_ROOT_THICKNESS))

# -- 5. Draw Link Edges -- (DRAWN AFTER HYPEREDGES)
if link_edges:
    lines.append(r"% Edges of the common {}-link graph of T".format(j))
    for u, v in link_edges:
        if u in vertices and v in vertices:
            lines.append(r"\draw[{}, color={}] ({}) -- ({});".format(LINK_EDGE_THICKNESS, LINK_EDGE_COLOR, u, v))
        else:
            print(f"Warning: Could not draw link edge between {u} and {v} - one or both vertices not defined.")

# -- 6. Draw Vertices (Foreground) -- (DRAWN LAST)
lines.append(r"% Draw vertices (foreground layer)")
# Vertices in S
for v_label in T:
    if v_label in vertices:
        lines.append(r"\fill[{}] ({}) circle ({:.1f}pt);".format(T_DOT_COLOR, v_label, DOT_THICKNESS))
        if ADD_VERTEX_LABELS:
            lines.append(r"\node[above right=1pt, color={}] at ({}) {{${}$}};".format(T_DOT_COLOR, v_label, v_label))
# Vertices in V \ T
for v_label in V_minus_T:
    if v_label in vertices:
        lines.append(r"\fill[{}] ({}) circle ({:.1f}pt);".format(V_MINUS_T_DOT_COLOR, v_label, DOT_THICKNESS))
        if ADD_VERTEX_LABELS:
            lines.append(
                r"\node[above right=1pt, color={}] at ({}) {{${}$}};".format(V_MINUS_T_DOT_COLOR, v_label, v_label))

lines.append(r"\end{tikzpicture}")

# --- Write TikZ code to a file ---
filename = "common_link.tex"
output_dir = "src/figures"  # Define output directory (optional)

# Ensure the output directory exists
if output_dir:
    os.makedirs(output_dir, exist_ok=True)
    full_path = os.path.join(output_dir, filename)
else:
    full_path = filename

# Write the TikZ code to the file
try:
    with open(full_path, "w") as f:
        f.write("\n".join(lines))
    print(f"\nTikZ code for the common link graph has been written to '{full_path}'")
    print(f" - Original hyperedges included: {DRAW_ORIGINAL_HYPEREDGES} (using uniform dimmed color)")
    print(f" - Layering: Hyperedges drawn ON TOP of boxes.")
    print(f" - T: {T}")
    print(f" - Common {j}-link edges found: {len(link_edges)}")
except IOError as e:
    print(f"Error writing file '{full_path}': {e}")
